import * as fs from 'fs';
import * as path from 'path';
import { execSync } from 'child_process';
import type { BenchmarkResults, PackageVersions, ReleaseInfo } from './types';

function getPackageVersions(): PackageVersions {
  const packageJson = JSON.parse(fs.readFileSync('package.json', 'utf8'));

  // Get installed versions
  const getInstalledVersion = (packageName: string): string => {
    try {
      const result = execSync(`pnpm list ${packageName} --depth=0 --json`, {
        encoding: 'utf8',
        stdio: 'pipe',
      });
      const parsed = JSON.parse(result);
      const version =
        parsed[0]?.dependencies?.[packageName]?.version ||
        packageJson.devDependencies?.[packageName]?.replace(/[\^~]/, '') ||
        'unknown';
      return version;
    } catch (error) {
      return (
        packageJson.devDependencies?.[packageName]?.replace(/[\^~]/, '') ||
        'unknown'
      );
    }
  };

  return {
    nx: getInstalledVersion('nx'),
    turbo: getInstalledVersion('turbo'),
    lerna: getInstalledVersion('lerna'),
    lage: getInstalledVersion('lage'),
    node: process.version.replace('v', ''),
    pnpm: packageJson.packageManager?.replace('pnpm@', '') || 'unknown',
  };
}

function generateTag(versions: PackageVersions): string {
  const { nx, turbo, lerna, lage } = versions;
  return `benchmark-nx${nx}-turbo${turbo}-lerna${lerna}-lage${lage}`;
}

function formatReleaseDescription(
  results: BenchmarkResults,
  versions: PackageVersions
): string {
  const date = new Date().toLocaleDateString('en-US', {
    year: 'numeric',
    month: 'long',
    day: 'numeric',
  });

  return `# üìä Monorepo Tools Benchmark Results - ${date}

## Performance Results

**Average Execution Times:**
- ü•á **Nx**: ${results.tools.nx.average.toFixed(1)}ms
- ü•à **Lerna (nx-powered)**: ${results.tools.lerna.average.toFixed(1)}ms
- ü•â **Turbo**: ${results.tools.turbo.average.toFixed(1)}ms
- üêå **Lage**: ${results.tools.lage.average.toFixed(1)}ms

**Performance Comparison (vs Nx):**
- Nx is **${results.comparisons.nxVsLage.toFixed(1)}x faster** than Lage
- Nx is **${results.comparisons.nxVsTurbo.toFixed(1)}x faster** than Turbo
- Nx is **${results.comparisons.nxVsLerna.toFixed(1)}x faster** than Lerna

## Tool Versions

| Tool | Version |
|------|---------|
| Nx | ${versions.nx} |
| Turbo | ${versions.turbo} |
| Lerna | ${versions.lerna} |
| Lage | ${versions.lage} |
| Node.js | ${versions.node} |
| PNPM | ${versions.pnpm} |

## Benchmark Details

- **Test Environment**: GitHub Actions (Ubuntu Latest)
- **Benchmark Type**: Cache restoration performance
- **Number of Runs**: ${results.runs}
- **Repository Size**: ~26k components across 5 apps and shared libraries
- **Test Date**: ${results.timestamp}

## Raw Results

\`\`\`json
${JSON.stringify(results, null, 2)}
\`\`\`

---

*This release was automatically generated by the daily benchmark workflow. The tag name includes all tool versions for easy filtering and historical tracking.*`;
}

function generateReleaseInfo(results: BenchmarkResults): ReleaseInfo {
  const versions = getPackageVersions();
  const tagName = generateTag(versions);
  const date = new Date().toLocaleDateString('en-US', {
    year: 'numeric',
    month: 'short',
    day: 'numeric',
  });

  return {
    tagName,
    releaseName: `üöÄ Benchmark Results - ${date} (Nx ${versions.nx}, Turbo ${versions.turbo})`,
    description: formatReleaseDescription(results, versions),
  };
}

async function checkIfReleaseExists(tagName: string): Promise<boolean> {
  try {
    execSync(`git ls-remote --tags origin ${tagName}`, { stdio: 'pipe' });
    return true;
  } catch {
    return false;
  }
}

function createGitHubReleaseOutputs(
  releaseInfo: ReleaseInfo,
  releaseExists: boolean
): void {
  // Output for GitHub Actions
  console.log(`tag-name=${releaseInfo.tagName}`);
  console.log(`release-name=${releaseInfo.releaseName}`);
  console.log(`release-exists=${releaseExists}`);

  // Write description to file for GitHub Actions
  fs.writeFileSync('release-description.md', releaseInfo.description);
  console.log('release-description-file=release-description.md');
}

async function main(): Promise<void> {
  const resultsJson = process.env.BENCHMARK_RESULTS;

  if (!resultsJson) {
    console.error('No benchmark results provided');
    process.exit(1);
  }

  try {
    const results: BenchmarkResults = JSON.parse(resultsJson);
    const releaseInfo = generateReleaseInfo(results);
    const releaseExists = await checkIfReleaseExists(releaseInfo.tagName);

    console.log(`Generated release info for tag: ${releaseInfo.tagName}`);
    console.log(`Release exists: ${releaseExists}`);

    createGitHubReleaseOutputs(releaseInfo, releaseExists);
  } catch (error) {
    console.error('Failed to create release info:', error);
    process.exit(1);
  }
}

if (require.main === module) {
  main();
}

export {
  getPackageVersions,
  generateTag,
  formatReleaseDescription,
  generateReleaseInfo,
  checkIfReleaseExists,
};
